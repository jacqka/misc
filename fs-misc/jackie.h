jfind.c���������������������������������������������������������������������������������������������0000664�0001750�0001750�00000007360�14222125030�011551� 0����������������������������������������������������������������������������������������������������ustar  �jackie��������������������������jackie�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include"jackie.h"
#include<stdbool.h>
#include<dirent.h>
#include<semaphore.h>
#include<pthread.h>

#define max_len 64
	
	/* like find, but where the math isnt good or finished */

struct name {

	int num_files;
	char *full_path[max_len];
	char *str;
	char *file;
	int str_sz;
	sem_t sem;	

	};

typedef struct concurrent_rddir {
		
		DIR *d2;
		struct dirent *d_two;
		size_t *fname;
		sem_t *sem;

} struct D2_CTX;


int second_thread_get_dir(pthread_t thread_two, sem_t safety,
				const char *d_name, struct name *nam){
	
		D2_CTX *d;
		sem_t *sem;

		memset(sem, nam->sem, sizeof(d->sem));

			d->sem = (sem_t *)malloc(sizeof(sem));

				DIR *dir = opendir(nam->d_name);
					

		while(( d->d2 = readdir(dir))!= NULL){	
		
			sem_wait(saftey, 0, NULL);

			calloc(d->fname, sizeof(d->d2->d_name));

				memcpy(d->fname, d->d2->d_name, sizeof(d->f_name));

						if (d->fname == nam->str){

								printf("%s", d->d2->d_name);
									bool file = 1;

								}

					}
			
			free(d2);
					
	return d->fname;


				}


/* 
 * get_dir()/second_thread_get_dir on 1st/2nd thread respectively */

int new_thread(	struct dirent *d, DIR *dir){
		

	pthread_create(thread_two, PTHREAD_CREATE_JOINABLE, second_thread_get_dir, nam);
	
		pthread_t *thread_two;
		struct name nam;
					
			sem_open(nam.sem, 0, 0);
				/* open at 0. just for one thread */				
					while (sem){

							/* dir turn function */

										}

}

/* each file in working directory */

struct name *parsename(DIR *dir, int namlen, char *file){
		
	struct name nam;
		
	size_t *cur = (struct name *)malloc(sizeof(nam));
		
		if (nam.str != file){
				
				return NULL;}
	
	
				else{
		
						memset(nam.full_path, 0, sizeof(nam.full_path));
		
						snprintf(nam.full_path, (sizeof(cur)+1), "%s/%s", dir, file);		

				nam.file = (void *)&file;
	
	return (struct name *)cur;}
}		



struct name *get_dir(DIR *dir, struct dirent *d, char *str){
		
	int dir_files = 0;
	
	while((d = readdir(dir)) != NULL){	

			if(!strcmp(d->d_name, ".") && !strcmp(d->d_name, "..")){
						dir_files++;}
			}
	
		int i = 1, b;
				
		int str_sz = strlen(str);
		rewinddir(dir);

			int *namelen[dir_files];
			char *files[dir_files];
	
	
	while((d = readdir(dir)) != NULL){
	
			memset(files[i], 0, sizeof(files[i]));
		
					if(!strcmp(d->d_name, ".") && !strcmp(d->d_name, "..")){
			
								files[i] = d->d_name;
			
								namelen[i] = strlen(d->d_name);

							if(namelen[i] == str_sz){
					
					struct name *nam = parsename(dir, namelen[i], files[i]); 
						
						if(str != nam->file){
									
									free(nam);
				
										continue; }
			else {
				
							nam->str = str;
							nam->num_files = dir_files;
							nam->str_sz = str_sz;

				return nam; }


		}}}
		

int main(int argc, char *argv[]){

		struct dirent *d;
		DIR *dir;
		
		argchk(argc, "p", 0);
		bool find;
		
		char ch, **path, **str;
		int str_sz;
		size_t *path_ptr;


	while((ch = getopt(argc, argv, ":p:s:")) != EOF){
		switch(ch){

			case'p':
					path = optarg;
					break;
			case's':		
					find = true;
					str = optarg;
					str_sz = strlen(optarg);
					break;

			}
		}


	
		dir = opendir(path);
		
			free(path);
	
	struct name *nam = get_dir(dir, d, str);
   
    pthread_t *thread_two;

	DIR *re;

		if(find){
		
			while(str != nam->file){
			
					rewinddir(dir);
			
				for(; i <= (nam->num_files) ; i++){
						d = readdir(dir);
				

						if (d->d_type == DT_DIR)
						{ 			new_thread(thread_two);}

								calloc(re, sizeof(re));
							
										memset(&re-re, d->d_name, sizeof(d->d_name));
			
											pthread_join(&thr, NULL)
						
										closedir(dir);
					
								memset(dir, 0, sizeof(dir));		
						
						dir = opendir(re);
								
			nam = get_dir(dir, d, str);
							
				};	
			}}}

	

return 0;}	

			

				
					
						}


#include<stdlib.h>
#include<string.h>
#include<stdbool.h>
#include<sys/stat.h>
#include<grp.h>
#include<pwd.h>
#include<fcntl.h>
#include<assert.h>



	
/* old gentoo thing */

int err(int flag){
	

	if (flag != 6) {
		printf("Please run as root !\n\n");}

	printf("\nUSAGE: -l 'category' -p 'PKG NAME' (-a 'ADD' || -r 'REMOVE')\n"); 
}

int permiss(FILE *fp, const char *newuse[], int flag){

	struct passwd *pwd;
	struct group *grp;
	
	gid_t *gid;
	uid_t *uid;
	uid_t *euid;

	uid = getpwuid(pwd);
	

	size_t *ptr = (void *)malloc(sizeof(pwd));
	
	int fd = open(newuse, O_RDWR);

	int stat = fchown(fd, uid, 1001);
		if (stat<0){
			perror("");
			err(NULL);}
	fclose(fd);
	
	free(&pwd);

	return 0;

}
	


int main(int argc, char *argv[]){
int stat;
	if ( (stat = geteuid()) != 0 || argc < 6 ){
		err(argc);
		return 1;}

	char chh;
	bool op = 1 || 0;
	const char **usepkg, **add, **remove, **lib;


while((chh = getopt(argc, argv, ":l:p:ar:")) != EOF){

	switch(chh){
		case'l':
			lib = argv[2];
			break;

		case'p':
			usepkg = argv[4];
			break;
				
		case'a':
			add = argv[6];
			op = 1;
			break;

		case'r':
			remove = argv[6];
			op = 0;
			break;
			}	
		}



FILE *fp;
char prefix[] = "/etc/portage/package.use/";
char *buffy[64], *newuse[64];

size_t **y = (void *)malloc(sizeof(buffy));
	
	memset(y, 0, sizeof(y));

	snprintf(newuse, sizeof(newuse), "%s/%s\0", prefix, usepkg);

	
	fp = fopen(newuse, "w");

		if(op){
			snprintf(y, 64, "%s/%s",lib, usepkg);}

		else{
			snprintf(y, 64, "%s/%s -",lib, usepkg);}
 
	
	fprintf(fp, "%s %s", y, argv[6]);
	permiss(fp, newuse, NULL);
	
	fclose(fp);
		printf("SUCCESSFUL!\n");	  
		printf("Good. Done. Probably..\n");
	
		return 0; }

	


				
���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������README.md�������������������������������������������������������������������������������������������0000664�0001750�0001750�00000000055�14221640233�011572� 0����������������������������������������������������������������������������������������������������ustar  �jackie��������������������������jackie�����������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������is things to make things a lil less annoying
���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
